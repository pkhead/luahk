const char* TASK_LIB_SRC = "local scheduled = {} local deferred = {}  local function spawn(f, ...) coroutine.resume(coroutine.create(f), ...) end  local function defer(f, ...) table.insert(deferred, { coroutine.create(f), ... }) end  local function wait(ms) table.insert(scheduled, { coroutine.running(), os.tick() + ms, os.tick() }) return coroutine.yield() end  os.update(function() local tick = os.tick()  for i=#scheduled, 1, -1 do local v = scheduled[i]  if tick >= v[2] then coroutine.resume(v[1], tick - v[3]) table.remove(scheduled, i) end end  for _, coro in ipairs(deferred) do coroutine.resume(table.unpack(coro)) end  deferred = {} end)  return { wait = wait, spawn = spawn, }";

const char* HOTKEY_SRC = "local active = {}\n"
"local isDown = {}\n"
"function os.sethotkey(hk, callback)\n"
	"if type(callback) ~= \"function\" then\n"
		"error(\"argument 2 not a function\")\n"
	"end\n"
	"local btns = {}\n"
	"for btn in string.gmatch(hk, \"([^+]+)\") do\n"
		"table.insert(btns, 1, btn)\n"
	"end\n"
	"table.insert(active, { btns, callback })\n"
"end\n"
"function os.kbhook(down, key)\n"
	"if down then\n"
		"isDown[key] = true\n"
		"for _, data in ipairs(active) do\n"
			"local combo, callback = table.unpack(data)\n"
			"if combo[1] == key then\n"
				"local isPressed = true\n"
				"for _, k in ipairs(combo) do\n"
					"if not isDown[k] then\n"
						"isPressed = false\n"
						"break\n"
					"end\n"
				"end\n"
				"if isPressed then\n"
					"callback()\n"
				"end\n"
			"end\n"
		"end\n"
	"else\n"
		"isDown[key] = nil\n"
	"end\n"
"end\n";